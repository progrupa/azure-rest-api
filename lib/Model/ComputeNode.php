<?php
/**
 * ComputeNode
 *
 * PHP version 5
 *
 * @category Class
 * @package  Progrupa\Azure
 * @author   Swaagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * BatchService
 *
 * A client for issuing REST requests to the Azure Batch service.
 *
 * OpenAPI spec version: 2016-07-01.3.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Progrupa\Azure\Model;

use \ArrayAccess;

/**
 * ComputeNode Class Doc Comment
 *
 * @category    Class
 * @package     Progrupa\Azure
 * @author      Swagger Codegen team
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class ComputeNode implements ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'ComputeNode';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = [
        'id' => 'string',
        'url' => 'string',
        'state' => 'string',
        'scheduling_state' => 'string',
        'state_transition_time' => '\DateTime',
        'last_boot_time' => '\DateTime',
        'allocation_time' => '\DateTime',
        'ip_address' => 'string',
        'affinity_id' => 'string',
        'vm_size' => 'string',
        'total_tasks_run' => 'int',
        'running_tasks_count' => 'int',
        'total_tasks_succeeded' => 'int',
        'recent_tasks' => '\Progrupa\Azure\Model\TaskInformation[]',
        'start_task' => '\Progrupa\Azure\Model\StartTask',
        'start_task_info' => '\Progrupa\Azure\Model\StartTaskInformation',
        'certificate_references' => '\Progrupa\Azure\Model\CertificateReference[]',
        'errors' => '\Progrupa\Azure\Model\ComputeNodeError[]'
    ];

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'url' => 'url',
        'state' => 'state',
        'scheduling_state' => 'schedulingState',
        'state_transition_time' => 'stateTransitionTime',
        'last_boot_time' => 'lastBootTime',
        'allocation_time' => 'allocationTime',
        'ip_address' => 'ipAddress',
        'affinity_id' => 'affinityId',
        'vm_size' => 'vmSize',
        'total_tasks_run' => 'totalTasksRun',
        'running_tasks_count' => 'runningTasksCount',
        'total_tasks_succeeded' => 'totalTasksSucceeded',
        'recent_tasks' => 'recentTasks',
        'start_task' => 'startTask',
        'start_task_info' => 'startTaskInfo',
        'certificate_references' => 'certificateReferences',
        'errors' => 'errors'
    ];


    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'url' => 'setUrl',
        'state' => 'setState',
        'scheduling_state' => 'setSchedulingState',
        'state_transition_time' => 'setStateTransitionTime',
        'last_boot_time' => 'setLastBootTime',
        'allocation_time' => 'setAllocationTime',
        'ip_address' => 'setIpAddress',
        'affinity_id' => 'setAffinityId',
        'vm_size' => 'setVmSize',
        'total_tasks_run' => 'setTotalTasksRun',
        'running_tasks_count' => 'setRunningTasksCount',
        'total_tasks_succeeded' => 'setTotalTasksSucceeded',
        'recent_tasks' => 'setRecentTasks',
        'start_task' => 'setStartTask',
        'start_task_info' => 'setStartTaskInfo',
        'certificate_references' => 'setCertificateReferences',
        'errors' => 'setErrors'
    ];


    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'url' => 'getUrl',
        'state' => 'getState',
        'scheduling_state' => 'getSchedulingState',
        'state_transition_time' => 'getStateTransitionTime',
        'last_boot_time' => 'getLastBootTime',
        'allocation_time' => 'getAllocationTime',
        'ip_address' => 'getIpAddress',
        'affinity_id' => 'getAffinityId',
        'vm_size' => 'getVmSize',
        'total_tasks_run' => 'getTotalTasksRun',
        'running_tasks_count' => 'getRunningTasksCount',
        'total_tasks_succeeded' => 'getTotalTasksSucceeded',
        'recent_tasks' => 'getRecentTasks',
        'start_task' => 'getStartTask',
        'start_task_info' => 'getStartTaskInfo',
        'certificate_references' => 'getCertificateReferences',
        'errors' => 'getErrors'
    ];

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    public static function setters()
    {
        return self::$setters;
    }

    public static function getters()
    {
        return self::$getters;
    }

    const STATE_IDLE = 'idle';
    const STATE_REBOOTING = 'rebooting';
    const STATE_REIMAGING = 'reimaging';
    const STATE_RUNNING = 'running';
    const STATE_UNUSABLE = 'unusable';
    const STATE_CREATING = 'creating';
    const STATE_STARTING = 'starting';
    const STATE_WAITINGFORSTARTTASK = 'waitingforstarttask';
    const STATE_STARTTASKFAILED = 'starttaskfailed';
    const STATE_UNKNOWN = 'unknown';
    const STATE_LEAVINGPOOL = 'leavingpool';
    const STATE_OFFLINE = 'offline';
    const SCHEDULING_STATE_ENABLED = 'enabled';
    const SCHEDULING_STATE_DISABLED = 'disabled';
    

    
    /**
     * Gets allowable values of the enum
     * @return string[]
     */
    public function getStateAllowableValues()
    {
        return [
            self::STATE_IDLE,
            self::STATE_REBOOTING,
            self::STATE_REIMAGING,
            self::STATE_RUNNING,
            self::STATE_UNUSABLE,
            self::STATE_CREATING,
            self::STATE_STARTING,
            self::STATE_WAITINGFORSTARTTASK,
            self::STATE_STARTTASKFAILED,
            self::STATE_UNKNOWN,
            self::STATE_LEAVINGPOOL,
            self::STATE_OFFLINE,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     * @return string[]
     */
    public function getSchedulingStateAllowableValues()
    {
        return [
            self::SCHEDULING_STATE_ENABLED,
            self::SCHEDULING_STATE_DISABLED,
        ];
    }
    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     * @param mixed[] $data Associated array of property values initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['url'] = isset($data['url']) ? $data['url'] : null;
        $this->container['state'] = isset($data['state']) ? $data['state'] : null;
        $this->container['scheduling_state'] = isset($data['scheduling_state']) ? $data['scheduling_state'] : null;
        $this->container['state_transition_time'] = isset($data['state_transition_time']) ? $data['state_transition_time'] : null;
        $this->container['last_boot_time'] = isset($data['last_boot_time']) ? $data['last_boot_time'] : null;
        $this->container['allocation_time'] = isset($data['allocation_time']) ? $data['allocation_time'] : null;
        $this->container['ip_address'] = isset($data['ip_address']) ? $data['ip_address'] : null;
        $this->container['affinity_id'] = isset($data['affinity_id']) ? $data['affinity_id'] : null;
        $this->container['vm_size'] = isset($data['vm_size']) ? $data['vm_size'] : null;
        $this->container['total_tasks_run'] = isset($data['total_tasks_run']) ? $data['total_tasks_run'] : null;
        $this->container['running_tasks_count'] = isset($data['running_tasks_count']) ? $data['running_tasks_count'] : null;
        $this->container['total_tasks_succeeded'] = isset($data['total_tasks_succeeded']) ? $data['total_tasks_succeeded'] : null;
        $this->container['recent_tasks'] = isset($data['recent_tasks']) ? $data['recent_tasks'] : null;
        $this->container['start_task'] = isset($data['start_task']) ? $data['start_task'] : null;
        $this->container['start_task_info'] = isset($data['start_task_info']) ? $data['start_task_info'] : null;
        $this->container['certificate_references'] = isset($data['certificate_references']) ? $data['certificate_references'] : null;
        $this->container['errors'] = isset($data['errors']) ? $data['errors'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = [];

        $allowed_values = ["idle", "rebooting", "reimaging", "running", "unusable", "creating", "starting", "waitingforstarttask", "starttaskfailed", "unknown", "leavingpool", "offline"];
        if (!in_array($this->container['state'], $allowed_values)) {
            $invalid_properties[] = "invalid value for 'state', must be one of 'idle', 'rebooting', 'reimaging', 'running', 'unusable', 'creating', 'starting', 'waitingforstarttask', 'starttaskfailed', 'unknown', 'leavingpool', 'offline'.";
        }

        $allowed_values = ["enabled", "disabled"];
        if (!in_array($this->container['scheduling_state'], $allowed_values)) {
            $invalid_properties[] = "invalid value for 'scheduling_state', must be one of 'enabled', 'disabled'.";
        }

        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {

        $allowed_values = ["idle", "rebooting", "reimaging", "running", "unusable", "creating", "starting", "waitingforstarttask", "starttaskfailed", "unknown", "leavingpool", "offline"];
        if (!in_array($this->container['state'], $allowed_values)) {
            return false;
        }
        $allowed_values = ["enabled", "disabled"];
        if (!in_array($this->container['scheduling_state'], $allowed_values)) {
            return false;
        }
        return true;
    }


    /**
     * Gets id
     * @return string
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     * @param string $id Every node that is added to a pool is assigned a unique ID. Whenever a node is removed from a pool, all of its local files are deleted, and the ID is reclaimed and could be reused for new nodes.
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets url
     * @return string
     */
    public function getUrl()
    {
        return $this->container['url'];
    }

    /**
     * Sets url
     * @param string $url
     * @return $this
     */
    public function setUrl($url)
    {
        $this->container['url'] = $url;

        return $this;
    }

    /**
     * Gets state
     * @return string
     */
    public function getState()
    {
        return $this->container['state'];
    }

    /**
     * Sets state
     * @param string $state
     * @return $this
     */
    public function setState($state)
    {
        $allowed_values = array('idle', 'rebooting', 'reimaging', 'running', 'unusable', 'creating', 'starting', 'waitingforstarttask', 'starttaskfailed', 'unknown', 'leavingpool', 'offline');
        if (!is_null($state) && (!in_array($state, $allowed_values))) {
            throw new \InvalidArgumentException("Invalid value for 'state', must be one of 'idle', 'rebooting', 'reimaging', 'running', 'unusable', 'creating', 'starting', 'waitingforstarttask', 'starttaskfailed', 'unknown', 'leavingpool', 'offline'");
        }
        $this->container['state'] = $state;

        return $this;
    }

    /**
     * Gets scheduling_state
     * @return string
     */
    public function getSchedulingState()
    {
        return $this->container['scheduling_state'];
    }

    /**
     * Sets scheduling_state
     * @param string $scheduling_state Possible values are: enabled – Tasks can be scheduled on the node. disabled – No new tasks will be scheduled on the node. Tasks already running on the node may still run to completion. All nodes start with scheduling enabled.
     * @return $this
     */
    public function setSchedulingState($scheduling_state)
    {
        $allowed_values = array('enabled', 'disabled');
        if (!is_null($scheduling_state) && (!in_array($scheduling_state, $allowed_values))) {
            throw new \InvalidArgumentException("Invalid value for 'scheduling_state', must be one of 'enabled', 'disabled'");
        }
        $this->container['scheduling_state'] = $scheduling_state;

        return $this;
    }

    /**
     * Gets state_transition_time
     * @return \DateTime
     */
    public function getStateTransitionTime()
    {
        return $this->container['state_transition_time'];
    }

    /**
     * Sets state_transition_time
     * @param \DateTime $state_transition_time
     * @return $this
     */
    public function setStateTransitionTime($state_transition_time)
    {
        $this->container['state_transition_time'] = $state_transition_time;

        return $this;
    }

    /**
     * Gets last_boot_time
     * @return \DateTime
     */
    public function getLastBootTime()
    {
        return $this->container['last_boot_time'];
    }

    /**
     * Sets last_boot_time
     * @param \DateTime $last_boot_time This property may not be present if the node state is unusable.
     * @return $this
     */
    public function setLastBootTime($last_boot_time)
    {
        $this->container['last_boot_time'] = $last_boot_time;

        return $this;
    }

    /**
     * Gets allocation_time
     * @return \DateTime
     */
    public function getAllocationTime()
    {
        return $this->container['allocation_time'];
    }

    /**
     * Sets allocation_time
     * @param \DateTime $allocation_time
     * @return $this
     */
    public function setAllocationTime($allocation_time)
    {
        $this->container['allocation_time'] = $allocation_time;

        return $this;
    }

    /**
     * Gets ip_address
     * @return string
     */
    public function getIpAddress()
    {
        return $this->container['ip_address'];
    }

    /**
     * Sets ip_address
     * @param string $ip_address Every node that is added to a pool is assigned a unique IP address. Whenever a node is removed from a pool, all of its local files are deleted, and the IP address is reclaimed and could be reused for new nodes.
     * @return $this
     */
    public function setIpAddress($ip_address)
    {
        $this->container['ip_address'] = $ip_address;

        return $this;
    }

    /**
     * Gets affinity_id
     * @return string
     */
    public function getAffinityId()
    {
        return $this->container['affinity_id'];
    }

    /**
     * Sets affinity_id
     * @param string $affinity_id
     * @return $this
     */
    public function setAffinityId($affinity_id)
    {
        $this->container['affinity_id'] = $affinity_id;

        return $this;
    }

    /**
     * Gets vm_size
     * @return string
     */
    public function getVmSize()
    {
        return $this->container['vm_size'];
    }

    /**
     * Sets vm_size
     * @param string $vm_size For information about available sizes of virtual machines for Cloud Services pools (pools created with cloudServiceConfiguration), see Sizes for Cloud Services (http://azure.microsoft.com/documentation/articles/cloud-services-sizes-specs/). Batch supports all Cloud Services VM sizes except ExtraSmall. For information about available VM sizes for pools using images from the Virtual Machines Marketplace (pools created with virtualMachineConfiguration) see Sizes for Virtual Machines (Linux) (https://azure.microsoft.com/documentation/articles/virtual-machines-linux-sizes/) or Sizes for Virtual Machines (Windows) (https://azure.microsoft.com/documentation/articles/virtual-machines-windows-sizes/). Batch supports all Azure VM sizes except STANDARD_A0 and those with premium storage (STANDARD_GS, STANDARD_DS, and STANDARD_DSV2 series).
     * @return $this
     */
    public function setVmSize($vm_size)
    {
        $this->container['vm_size'] = $vm_size;

        return $this;
    }

    /**
     * Gets total_tasks_run
     * @return int
     */
    public function getTotalTasksRun()
    {
        return $this->container['total_tasks_run'];
    }

    /**
     * Sets total_tasks_run
     * @param int $total_tasks_run
     * @return $this
     */
    public function setTotalTasksRun($total_tasks_run)
    {
        $this->container['total_tasks_run'] = $total_tasks_run;

        return $this;
    }

    /**
     * Gets running_tasks_count
     * @return int
     */
    public function getRunningTasksCount()
    {
        return $this->container['running_tasks_count'];
    }

    /**
     * Sets running_tasks_count
     * @param int $running_tasks_count
     * @return $this
     */
    public function setRunningTasksCount($running_tasks_count)
    {
        $this->container['running_tasks_count'] = $running_tasks_count;

        return $this;
    }

    /**
     * Gets total_tasks_succeeded
     * @return int
     */
    public function getTotalTasksSucceeded()
    {
        return $this->container['total_tasks_succeeded'];
    }

    /**
     * Sets total_tasks_succeeded
     * @param int $total_tasks_succeeded
     * @return $this
     */
    public function setTotalTasksSucceeded($total_tasks_succeeded)
    {
        $this->container['total_tasks_succeeded'] = $total_tasks_succeeded;

        return $this;
    }

    /**
     * Gets recent_tasks
     * @return \Progrupa\Azure\Model\TaskInformation[]
     */
    public function getRecentTasks()
    {
        return $this->container['recent_tasks'];
    }

    /**
     * Sets recent_tasks
     * @param \Progrupa\Azure\Model\TaskInformation[] $recent_tasks
     * @return $this
     */
    public function setRecentTasks($recent_tasks)
    {
        $this->container['recent_tasks'] = $recent_tasks;

        return $this;
    }

    /**
     * Gets start_task
     * @return \Progrupa\Azure\Model\StartTask
     */
    public function getStartTask()
    {
        return $this->container['start_task'];
    }

    /**
     * Sets start_task
     * @param \Progrupa\Azure\Model\StartTask $start_task
     * @return $this
     */
    public function setStartTask($start_task)
    {
        $this->container['start_task'] = $start_task;

        return $this;
    }

    /**
     * Gets start_task_info
     * @return \Progrupa\Azure\Model\StartTaskInformation
     */
    public function getStartTaskInfo()
    {
        return $this->container['start_task_info'];
    }

    /**
     * Sets start_task_info
     * @param \Progrupa\Azure\Model\StartTaskInformation $start_task_info
     * @return $this
     */
    public function setStartTaskInfo($start_task_info)
    {
        $this->container['start_task_info'] = $start_task_info;

        return $this;
    }

    /**
     * Gets certificate_references
     * @return \Progrupa\Azure\Model\CertificateReference[]
     */
    public function getCertificateReferences()
    {
        return $this->container['certificate_references'];
    }

    /**
     * Sets certificate_references
     * @param \Progrupa\Azure\Model\CertificateReference[] $certificate_references For Windows compute nodes, the Batch service installs the certificates to the specified certificate store and location. For Linux compute nodes, the certificates are stored in a directory inside the task working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to query for this location. For certificates with visibility of remoteuser, a certs directory is created in the user's home directory (e.g., /home/<user-name>/certs) where certificates are placed.
     * @return $this
     */
    public function setCertificateReferences($certificate_references)
    {
        $this->container['certificate_references'] = $certificate_references;

        return $this;
    }

    /**
     * Gets errors
     * @return \Progrupa\Azure\Model\ComputeNodeError[]
     */
    public function getErrors()
    {
        return $this->container['errors'];
    }

    /**
     * Sets errors
     * @param \Progrupa\Azure\Model\ComputeNodeError[] $errors
     * @return $this
     */
    public function setErrors($errors)
    {
        $this->container['errors'] = $errors;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\Progrupa\Azure\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\Progrupa\Azure\ObjectSerializer::sanitizeForSerialization($this));
    }
}


