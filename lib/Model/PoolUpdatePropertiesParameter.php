<?php
/**
 * PoolUpdatePropertiesParameter
 *
 * PHP version 5
 *
 * @category Class
 * @package  Progrupa\Azure
 * @author   Swaagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * BatchService
 *
 * A client for issuing REST requests to the Azure Batch service.
 *
 * OpenAPI spec version: 2016-07-01.3.1
 * 
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 *
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Progrupa\Azure\Model;

use \ArrayAccess;

/**
 * PoolUpdatePropertiesParameter Class Doc Comment
 *
 * @category    Class
 * @package     Progrupa\Azure
 * @author      Swagger Codegen team
 * @link        https://github.com/swagger-api/swagger-codegen
 */
class PoolUpdatePropertiesParameter implements ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      * @var string
      */
    protected static $swaggerModelName = 'PoolUpdatePropertiesParameter';

    /**
      * Array of property to type mappings. Used for (de)serialization
      * @var string[]
      */
    protected static $swaggerTypes = [
        'start_task' => '\Progrupa\Azure\Model\StartTask',
        'certificate_references' => '\Progrupa\Azure\Model\CertificateReference[]',
        'application_package_references' => '\Progrupa\Azure\Model\ApplicationPackageReference[]',
        'metadata' => '\Progrupa\Azure\Model\MetadataItem[]'
    ];

    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of attributes where the key is the local name, and the value is the original name
     * @var string[]
     */
    protected static $attributeMap = [
        'start_task' => 'startTask',
        'certificate_references' => 'certificateReferences',
        'application_package_references' => 'applicationPackageReferences',
        'metadata' => 'metadata'
    ];


    /**
     * Array of attributes to setter functions (for deserialization of responses)
     * @var string[]
     */
    protected static $setters = [
        'start_task' => 'setStartTask',
        'certificate_references' => 'setCertificateReferences',
        'application_package_references' => 'setApplicationPackageReferences',
        'metadata' => 'setMetadata'
    ];


    /**
     * Array of attributes to getter functions (for serialization of requests)
     * @var string[]
     */
    protected static $getters = [
        'start_task' => 'getStartTask',
        'certificate_references' => 'getCertificateReferences',
        'application_package_references' => 'getApplicationPackageReferences',
        'metadata' => 'getMetadata'
    ];

    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    public static function setters()
    {
        return self::$setters;
    }

    public static function getters()
    {
        return self::$getters;
    }

    

    

    /**
     * Associative array for storing property values
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     * @param mixed[] $data Associated array of property values initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['start_task'] = isset($data['start_task']) ? $data['start_task'] : null;
        $this->container['certificate_references'] = isset($data['certificate_references']) ? $data['certificate_references'] : null;
        $this->container['application_package_references'] = isset($data['application_package_references']) ? $data['application_package_references'] : null;
        $this->container['metadata'] = isset($data['metadata']) ? $data['metadata'] : null;
    }

    /**
     * show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalid_properties = [];

        if ($this->container['certificate_references'] === null) {
            $invalid_properties[] = "'certificate_references' can't be null";
        }
        if ($this->container['application_package_references'] === null) {
            $invalid_properties[] = "'application_package_references' can't be null";
        }
        if ($this->container['metadata'] === null) {
            $invalid_properties[] = "'metadata' can't be null";
        }
        return $invalid_properties;
    }

    /**
     * validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {

        if ($this->container['certificate_references'] === null) {
            return false;
        }
        if ($this->container['application_package_references'] === null) {
            return false;
        }
        if ($this->container['metadata'] === null) {
            return false;
        }
        return true;
    }


    /**
     * Gets start_task
     * @return \Progrupa\Azure\Model\StartTask
     */
    public function getStartTask()
    {
        return $this->container['start_task'];
    }

    /**
     * Sets start_task
     * @param \Progrupa\Azure\Model\StartTask $start_task If this element is present, it overwrites any existing start task. If omitted, any existing start task is removed from the pool.
     * @return $this
     */
    public function setStartTask($start_task)
    {
        $this->container['start_task'] = $start_task;

        return $this;
    }

    /**
     * Gets certificate_references
     * @return \Progrupa\Azure\Model\CertificateReference[]
     */
    public function getCertificateReferences()
    {
        return $this->container['certificate_references'];
    }

    /**
     * Sets certificate_references
     * @param \Progrupa\Azure\Model\CertificateReference[] $certificate_references If you specify an empty collection, any existing certificate references are removed from the pool. For Windows compute nodes, the Batch service installs the certificates to the specified certificate store and location. For Linux compute nodes, the certificates are stored in a directory inside the task working directory and an environment variable AZ_BATCH_CERTIFICATES_DIR is supplied to the task to query for this location. For certificates with visibility of remoteuser, a certs directory is created in the user's home directory (e.g., /home/<user-name>/certs) where certificates are placed.
     * @return $this
     */
    public function setCertificateReferences($certificate_references)
    {
        $this->container['certificate_references'] = $certificate_references;

        return $this;
    }

    /**
     * Gets application_package_references
     * @return \Progrupa\Azure\Model\ApplicationPackageReference[]
     */
    public function getApplicationPackageReferences()
    {
        return $this->container['application_package_references'];
    }

    /**
     * Sets application_package_references
     * @param \Progrupa\Azure\Model\ApplicationPackageReference[] $application_package_references Changes to application package references affect all new compute nodes joining the pool, but do not affect compute nodes that are already in the pool until they are rebooted or reimaged. The list replaces any existing application package references. If omitted, or if you specify an empty collection, any existing application packages references are removed from the pool.
     * @return $this
     */
    public function setApplicationPackageReferences($application_package_references)
    {
        $this->container['application_package_references'] = $application_package_references;

        return $this;
    }

    /**
     * Gets metadata
     * @return \Progrupa\Azure\Model\MetadataItem[]
     */
    public function getMetadata()
    {
        return $this->container['metadata'];
    }

    /**
     * Sets metadata
     * @param \Progrupa\Azure\Model\MetadataItem[] $metadata This list replaces any existing metadata configured on the pool. If omitted, or if you specify an empty collection, any existing metadata is removed from the pool.
     * @return $this
     */
    public function setMetadata($metadata)
    {
        $this->container['metadata'] = $metadata;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     * @param  integer $offset Offset
     * @return boolean
     */
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     * @param  integer $offset Offset
     * @return mixed
     */
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     * @param  integer $offset Offset
     * @param  mixed   $value  Value to be set
     * @return void
     */
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     * @param  integer $offset Offset
     * @return void
     */
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(\Progrupa\Azure\ObjectSerializer::sanitizeForSerialization($this), JSON_PRETTY_PRINT);
        }

        return json_encode(\Progrupa\Azure\ObjectSerializer::sanitizeForSerialization($this));
    }
}


